<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>07.3 Типы ссылок Java</title>
	<base target="_blank">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" >
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/idea.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/valladim-pw/java-level2-lessons@master/src/A_Visual-Materials/styles/style.css">-->
	<link rel="stylesheet" href="styles/style.css">	
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
	<style >
	</style>
</head>
<body onload="insertLabel(); two();">
<div class="container-fluid p-3">
	<div class="header" id="header">
		<p>Кнопками можно регулировать размер колонок L(левая) и R(правая) от 100% до 0% с шагом 10% (по умолчанию 50%/50%).</p>
		<div class="but-wrap">
			<div class="back-fix"></div>
		  <div class="but100-wrap left">
				<button class="btn" onclick="oneLeft();">100L</button>
			</div>
		  <div class="zoomBut">
				<button class="btn" onclick="zoomLeft();" >50L</button>
				<button class="btn" onclick="zoomRight();" >50R</button>
			</div>
			<div class="but100-wrap right">
				<button class="btn" onclick="oneRight();">100R</button>
			</div>
			<div class="but50-wrap">
				<button class="btn active" onclick="two();">50L&nbsp;&nbsp;&nbsp;&nbsp;50R<div class="divider"></div></button>
			</div>
		</div>
	</div>
	<div class="row">
		<div class="column">
			<span class="badge bg-primary">Рис.1&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.1.png" >
			<p></p>
			<p><b>Дополнительные материалы по теме</b>:</p>
			<p onclick="openWin1a()">
			<script>
			function openWin1a() {
			  window.open("https://habr.com/ru/articles/549176/","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <a class="github" href="https://habr.com/ru/articles/549176/">
			Управление памятью Java</a>
			</p>
			<p onclick="openWin1b()">
			<script>
			function openWin1b() {
			  window.open("https://javarush.com/groups/posts/1267-otlichija-mezhdu-slabihmi-mjagkimi-fantomnihmi-i-obihchnihmi-ssihlkami-v-java","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <a class="github" href="https://javarush.com/groups/posts/1267-otlichija-mezhdu-slabihmi-mjagkimi-fantomnihmi-i-obihchnihmi-ssihlkami-v-java">
			Отличия между слабыми, мягкими, фантомными и обычными ссылками в Java</a>
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.2&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.2.png">
			<p>
			
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.3&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.3.png">	
			<p>		
			* Класс <i>CallGC</i> наглядно демонстрирут работу сборщика мусора.</br>
			* При выводе результатов на консоль видно, что при создании большого количества объектов на каждой итерации цикла количество свободной памяти явно
			уменьшается (подчеркнуто красным) по отношению к изначальному (подчеркнуто зеленым), а после явного включения сборщика методом <i>System.gc()</i> свободная память возвращается к примерно одинаковому на каждой итерации размеру (подчеркнуто синим).
			В данном случае сборщик на основе статистики определяет, что такого количества памяти хватит для работы программы.</br>	
			</p>
			<p onclick="openWin1()">
			<script>
			function openWin1() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.4&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.4.png">
			<p >			
			* Несмотря на нежелательность явного вызова сборки мусора, есть случаи, когда для вызова есть основания:</br>
			- Очистка кэша (об этом позднее в лекции).</br>
			- При старте сервера, когда создается большое количество объектов, которые потом вряд ли пригодятся.</br>
			- Поиск утечек памяти в процессе отладки и настройки программы.</br>
			</p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.5&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.5.png">
			<p>			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.6&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.6.png">			
			<p>	
			* В данном примере мы оборачиваем объект <i>StringBuffer</i> объектами <b>SoftReference</b> (мягкая ссылка) и <b>WeakReference</b> (слабая ссылка)
			и получаем их значения методом <i>get</i>.</br>
			* После вызова явной сборки мусора мы видим, что ссылка <b>weakRef = null</b>, то есть объект, обернутый слабой ссылкой больше не существует, он очищен сборщиком мусора.</br>
			</p>
			<p onclick="openWin2()">
			<script>
			function openWin2() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.7&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.7.png">
			<p>
			* На рисунке наглядно показано, что представляет из себя <b>слабая ссылка</b>.</br>
			* Если слабая ссылка на объект <b>А</b>, от  которого идут три сильных ссылки к объектам <b>B</b>, <b>C</b> и <b>D</b> исчезнет, то соответственно
			исчезнут и эти объекты. Это следует из технологии поиска сборщиком <i>G1</i> живых объектов (объекты определяются как живые, толко если на них есть ссылки).</br>
			* Если слабая ссылка превращается в <i>null</i>, то и объекты <b>B</b>, <b>C</b> и <b>D</b> станут мусором и будут удалены.</br>
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.8&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.8.png">
			<p>
			* Если рассмотреть работу сборщика на цепочке от корневых элементов, то будут отправлены в мусор все объекты в сегменте идущем после слабой ссылки (при условии, что на них
			нет ссылок из других ветвей дерева).</br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.9&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.9.png">
			<p>
			* В данном примере мы создаем мягкую ссылку вокруг объекта класса <i>SoftRefResearch</i>, который содержит сильную ссылку на объект <i>StringBuffer</i>.</br>
			* Далее мы создаем ссылку на <i>StringBuffer</i> (красный цвет), которая содержит мягкую ссылку на объект класса <i>SoftRefResearch</i> (зеленый цвет), а внутри объекта 
			 через его свойство <b>sb</b> создаем уже сильную ссылку на <i>StringBuffer</i>.</br>
		  * При выводе на консоль мягкой ссылки мы видим объект класса <i>SoftRefResearch</i> (1).</br>
			* Потом мы через список и цикл заполняем память объектами списка, при этом неявно вызывая сборщик мусора. 
			После этого при выводе на консоль мягкой ссылки (2), мы видим, что она уже равна <b>null</b>, т.е. сборщик ее почистил.</br>
			* Но если мы выведем на консоль созданную внутри мягкой ссылки сильную ссылку <b>sb</b> (3), мы увидим ее значение, заданное через аргумент в конструкторе.</br>
			</p>
			<p onclick="openWin3()">
			<script>
			function openWin3() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.10&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.10.png">
			<p>
			
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.11&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.11.png">
			<p>
			* Механизм мягких ссылок хорош тем, что можно работающие программы, которые используют кэш, переделать на кэш с мягкой ссылкой. Изменения при этом будут минимальны, 
			но мы получим возможность очистки кэша самой <i>JVM</i>. </br>
			* Для примера возьмем <i>HashMap</i> по числам Фибоначчи <i>casheFibo</i>. </br>
			* Чтобы переделать <i>casheFibo</i> на кэш с мягкой ссылкой нужно всего лишь обернуть <i>HashMap</i> мягкой ссылкой <b>SoftReference</b>, а также исправить 
			появившиеся при этом ошибки в коде (подчеркнуто зеленым). </br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.12&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.12.png">
			<p>
			* В интернете бытует мнение, что в зависимости от частоты обращения к объекту, который обернут в мягкую ссылку, зависит как  быстро он будет удален. </br>
			* Пример выше показывает, <b>что это неправильное мнение</b>. Для проверки применяется следующая методика: </br>
			1. Заводим два массива с одинаковым достаточно большим количеством элементов. Массивы обернуты в мягкие ссылки <b>srIntArr1</b> и <b>srIntArr2</b>. </br>
			2. Один из массивов - <b>srIntArr1</b> наполняем значениями. </br>
			3. Создаем список и в цикле наполняем его значениями под завязку, чтобы память была переполнена. </br>
			4. В условии проверяем, если объект <b>srIntArr1</b>, к которому мы постоянно обращаемся, не равен <i>null</i>, а в тоже время другой, незадействованный объект  
			<b>srIntArr2</b> равен <i>null</i> - выводим соответствующее сообщение и выходим из цикла. </br>
			5. При условии если объект <b>srIntArr1</b>, к которому мы постоянно обращаемся, равен <i>null</i> - выводим другое сообщение и выходим из цикла. </br>
			6. Выводим значения ссылок на оба тестируемых объекта на консоль. </br>
			* При выводе на консоль мы видим, что срабатывает условие 5 и при этом ссылки на объекты (6) <b>одновременно</b> равны <i>null</i>. </br>
			</p>
			<p onclick="openWin4()">
			<script>
			function openWin4() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.13&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.13.png">
			<p>
			* Параметр достаточно относительный, по идее позволяет влиять на время жизни ссылки после того, как сборщик перестал ее видеть (по умолчанию - 1000 мс или 1 сек). Если за это время ссылка
			не используется, то сборщик может ее зачистить, хотя это и не гарантированно.</br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.14&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.14.png">
			<p>
			</p>
			
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.15&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.15.png">
			<p>
			* Если в <b>WeakHashMap</b> есть какой-либо ключ, имеющий сильную ссылку, то этот объект будет жить, но как только сильная ссылка исчезает
			из <i>WeakHashMap</i> будет удален не только ключ, но и значение, которое было доступно по данному ключу.</br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.16&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.16.png">
			<p>
			* Рассмотрим пример работы <b>WeakHashMap</b>, где ключом будет строка с именем файла, а значением - строка с текстом файла.<br>
			* Сначала инициируем пустой <i>WeakHashMap</i> <b>files</b>. Далее мы формируем список <b>fileNames</b> с именами трех файлов <b>file1</b>, <b>file2</b>, <b>file3</b>.</br>
			* Через цикл наполняем содержимым <i>WeakHashMap</i> <b>files</b>, устанавливая ключом имена файлов из <b>fileNames</b>, а значением считанное одной строкой содержимое этих файлов.</br>
			* Из <i>files</i> выводим информацию на консоль, получая тексты - содержимое файлов (1).</br>
			* Затем из <i>fileNames</i> удаляем первое и последнее значение (2) (<b>мы работаем со списком имен файлов, не касаясь WeakHashMap</b>).</br>
			* После запуска сборщика мусора выводим на консоль значения <i>files</i> (3) и видим, что первое и последнее значения равны <b>null</b>, то есть сборщик мусора удалил их 
			после того, как на 2-ом этапе стали <b>null</b> ключи - имена файлов.</br>
			</p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.17&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.17.png">
			<p>
		
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.18&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.18.png">
			<p>
			* Еще один инструмент - это очередь очищенных ссылок <b>ReferenceQueue</b>.<br>
			* Используется этот инструмент исключительно в исследовательских целях.<br>
			* Рассмотрим пример на слабых ссылках:<br>
			1. Инициализируем очередь <i>ReferenceQueue</i> от <i>Integer</i> и далее будем работать с этим классом.<br>
			2. Создаем слабые ссылки от трех значений <i>Integer</i> - <b>1001</b>, <b>1002</b>, <b>1003</b> (почему не 1, 2, 3 ?  Для целочисленных значений 
			в диапазоне от -128 до +127 объекты-обертки кэшируются внутри класса <i>Integer</i> для повторного использования, поэтому слабые ссылки не сработают),
			выводим эти ссылки на консоль.
			</p>
			<p onclick="openWin5()">
			<script>
			function openWin5() {
			  window.open("https://javarush.com/forum/382","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="https://javarush.com/forum/382">			
			Кеширование в Integer</a></i></p>
			<p>
			3. С помощью метода <i>poll</i> определяем пуста ли очередь. Она пуста.<br>
			4. Запускаем сборщик и выводим с помощью метода <i>remove(таймаут)</i> на консоль сами ссылки и обернутые ими <i>Integer</i> (которые зачищены и равны <i>null</i>).<br>
			* <ins>В данном случае по ссылкам можно отследить порядок, в котором сборщик очищает объекты и это может пригодиться при отладке или настройке приложения</ins>.<br>
			<br>
			</p>
			<p onclick="openWin6()">
			<script>
			function openWin6() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.19&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.19.png" usemap="#map">
			<p>
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.20&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.20.png">
			<p>			
			</p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.21&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.21.png">
			<p>	
						
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.22&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.22.png">
			<p>
			
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.23&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.23.png">
			<p onclick="openWin7()">
			<script>
			function openWin7() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>		
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.24&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.24.png">
			<p onclick="openWin8()">
			<script>
			function openWin8() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>				
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.25&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.25.png">
			<p onclick="openWin9()">
			<script>
			function openWin9() {
			  window.open("","_blank","toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=700, height=700");
			}
			</script>
			* <i class="github-wrap"><a class="github" href="">			
			.java</a><i class="fa fa-github"></i></i></p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.26&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.26.png">
			<p>		
			</p>			
		</div>
		<!--<div class="column">
			<span class="badge bg-primary">Рис.27&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.27.png">
			<p>							
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.28&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.28.png">			
			<p>
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.29&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.29.png">
			<p>
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.30&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.30.png">
			<p>
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.31&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.31.png">
			<p>	
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.32&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.32.png">
			<p>
			* Более подробно один цикл сборки мусора <i>Shenandoah</i> показан на рис.32, 33. Условно процесс можно разделить на два этапа.</br>
			* Первый этап - <b>поиск живых объектов</b> на рисунке выше, он состоит из нескольких фаз: </br>
			1. <b>Начальное состояние кучи</b> на старте цикла сборки.</br>
			2. <b>Фаза Init Mark</b> - выполняется в рамках паузы <i>STW</i>, и отведена для поиска объектов, достижимых из корней. После ее завершения куча имеет такой вид</br>
			3. <b>Фаза Concurrent Marking</b> - в конкурентном режиме, при работающих основных потоках приложения производится обход всей кучи, начиная с найденных на предыдущем шаге объектов,
			и сбор информации об остальных достижимых объектах. При этом приложение продолжает создавать новые объекты одновременно с процессом сборки мусора.
			Чтобы в таких условиях ничего не потерять <a href="https://habr.com/ru/post/680038/#barriers" target="_blank">функции-барьеры (подробнее по ссылке)</a>
			отслеживают изменения ссылок из одних объектов на другие, и запоминают "предыдущие" указатели в специальные коллекции. Это позволяет реализовывать режим <i>SATB</i> (рис.24, коммент.5)</br>
			4. <b>Фаза Final Mark</b> - во время паузы <i>STW</i> анализируются данные по появившимся новым корням, по коллекциями "предыдущих" указателей и т.п. и на их основе выявляются все достижимые объекты.</br>
			5. В этой фазе также, на основе статистики собираемой <i>GC</i> по регионам выбираются регионы для очистки в данном цикле.</br>
			6. В этой же фазе производится перемещение достижимых из корней объектов в новые целевые регионы. При перемещении изменяются указатели перенаправления у объектов на их старом месте (пунктирные стрелки).</br>
			</p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.33&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.33.png">
			<p>			
			* Второй этап можно условно назвать <b>перемещение</b>, он также состоит из нескольких фаз: </br>
			7. <b>Фаза Concurrent Evacuation</b> - в конкурентном режиме происходит перенос оставшихся живых объектов из очищаемых регионов в целевые регионы с одновременным обновлением указателей перенаправления на них.
			Если к началу этой фазы в каких-то из очищаемых регионов вообще не осталось живых объектов, такие регионы сразу же высвобождаются.
			</br>
			8. <b>Фаза Init Update Refs</b> - эта фаза представляет собой очень короткую <i>STW</i>-паузу, которая нужна для синхронизации потоков <i>GC</i> и подготовки к следующей фазе.</br>
			9. <b>Фаза Concurrent Update Refs</b> - на данной фазе, в конкурентном режиме производится модификация указателей на живые объекты, перенесенные в целевые области.</br>
			10. <b>Фаза Final Update Refs</b> - во время фазы происходит последняя пауза <i>STW</i> в рамках одного цикла, во время которой обновляются оставшиеся указатели на объекты, главным образом из новых корней.</br>
			11. <b>Результат сборки мусора</b> получаем в конце цикла, после того, как очищенные регионы возвращаются в список свободных.</br>
			</p>		
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.34&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.34.png">
			<p>	
			* Для того, чтобы использовать параметр <b>-XX:+UseShenandoahGC</b> нужно обязательно указать опцию <br>
			<b>-XX:+UnlockExperimentalVMOptions</b> с плюсом (по умолчанию она <i>false</i>).<br>			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.35&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.35.png">
			<p>
			
			</p>			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.36&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.36.png">
			<p>
			* При выборе сборщика особенно важны первые два параметра - продолжительность <b>пауз STW</b> и <b>производительность</b>.<br> 
			* Но поскольку зависимость этих параметров обратно пропорциональная (то есть чем меньше продолжительность пауз <i>STW</i>, тем больше процент времени работы сборщика
			от времени работы программы и наоборот) - то идеального сборщика не существует, можно найти только более-менее оптимальный вариант.<br>
			</p>
			
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.37&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.37.png">
			<p>
			* На схеме визуально показано, полученное эмпирическим путем, соотношение основных параметров (рис.36) у разных типов сборщиков мусора.<br>
			* Оптимальный вариантом является <i>G1 GC</i> .<br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.38&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.38.png">
			<p>			
			</p>			
		</div>
		<!--<div class="column">
			<span class="badge bg-primary">Рис.39&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.39.png">
			<p>
			* Теперь, если мы запустим в проекте <i>Maven1</i> фазу <b>verify</b> в отчете мы увидим, что плагин отработал с заданной целью (выделено красным).<br>
			
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.40&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.40.png">
			<p>
			* В результате успешной сборки в проекте <i>Maven1</i> в каталоге <b>target</b> появился файл <b>touch.txt</b> (выделено зеленым), а если посмотреть его содержимое,
			то в файле появилась очередная строка с временем и датой совпадающими с временем и датой окончания сборки (выделено красным).<br>
			</p>
		</div>
		<div class="column">
			<span class="badge bg-primary">Рис.41&nbsp;<i class="material-icons">&#xe5db;</i></span>
			<img src="images/images_07.3/07.3.41.png">
			<p>
			
			</p>
		</div>-->
	</div>
</div>
<!--<script src="https://cdn.jsdelivr.net/gh/valladim-pw/java-level2-lessons@master/src/A_Visual-Materials/javascript/script.js"></script>-->
<script src="javascript/script.js"></script>
</body>
</html>









